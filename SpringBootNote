https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle

20. Developer Tools
	spring-boot-devtools 为开发者提供许多方便的舒适的开发环境。
	当你使用 java -jar 命令启动应用时，spring-boot-devtools 会认为应用处于生产环境而不启用，或者你可以使用 -Dspring.devtools.restart.enabled=false 配置手动关闭 spring-boot-devtools。
	spring-boot-devtools 会监听所有 classpath 下的任何改动，并在 class 文件发生变化后进行程序的热部署。
	通过配置 spring.devtools.restart.trigger-file，可以指定在某个文件修改之后触发项目重启。
	
	spring-boot-devtools 可以让你方便地进行远程热部署。首先将 devtools 包含在打包插件中
		<build>
			<plugins>
				<plugin>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-maven-plugin</artifactId>
					<configuration>
						<excludeDevtools>false</excludeDevtools>
					</configuration>
				</plugin>
			</plugins>
		</build>
	然后为你的项目设置一个密码 spring.devtools.remote.secret=mysecret。项目直接部署在远程服务器上。
	本地 IDE 中新建 Java Application 启动器，选择相应的 Module，以 org.springframework.boot.devtools.RemoteSpringApplication 作为启动类，远程服务器地址作为启动参数。你在本地环境的任何修改将被同步推送到远程服务中，如果需要的话，还会触发服务重启。

23.5 Application Events and Listeners
	在 SpringBoot 启动的之前，可以通过 SpringApplication.addListeners 设置自己的 ApplicationListener 来监听 SpringBoot 初始化过程中的各种事件，常见的 SpringBoot 的启动事件顺序是：
	ApplicationStartingEvent —— SpringBoot 开始运行，除了注册监听器和初始化模块，还没有运行任何进程
	ApplicationEnvironmentPreparedEvent —— 上下文环境已知但上下文被创建之前
	ApplicationPreparedEvent —— Sprint bean 已经加载但上下文刷新开始之前
	ApplicationStartedEvent —— 上下文刷新之后但还没有运行任何应用和命令行
	ApplicationReadyEvent —— 所有应用和命令行运行完毕，表明程序已经准备好进行服务
	ApplicationFailedEvent —— 如果启动过程中有异常发生

23.8 Using the ApplicationRunner or CommandLineRunner
	通过实现 ApplicationRunner 或 CommandLineRunner 接口的 bean，可以在 SpringApplication 启动之后执行指定的代码。当有多个 ApplicationRunner 或 CommandLineRunner 的 bean 时，通过 org.springframework.core.annotation.Order 指定顺序。

23.9 Application Exit
	调用 SpringApplication.exit(ApplicationContext context, ExitCodeGenerator... exitCodeGenerators) 方法可以优雅地结束 ApplicationContext。

24. Externalized Configuration
	SpringBoot 使用以下顺序去设置一个属性的值：
	1. 当 devtools 可用时，~/.spring-boot-devtools.properties 配置文件
	2. 在测试时，使用 @TestPropertySource 注解的值
	3. 当测试时，测试目录下的 properties 配置文件
	4. 命令行参数，以 -- 开头
	5. SPRING_APPLICATION_JSON 设置的属性
	6. ServletConfig 初始化参数
	7. ServletContext 初始化参数
	8. 来自于 java:comp/env 的 JNDI 属性
	9. System.getProperties()
	10. 操作系统环境变量
	11. 使用 random.* 指定的随机数，取值参考 RandomValuePropertySource
	12. Jar 包外部指定的 application-{profile}.properties 配置文件
	13. Jar 包内部指定的 application-{profile}.properties 配置文件
	14. Jar 包外部指定的 application.properties 配置文件
	15. Jar 包内部指定的 application.properties 配置文件
	16. @Configuration 注解的类以 @PropertySource 注解指定的配置文件
	17. 默认配置
	
	可以使用 java -jar app.jar --key="value" 的启动方式指定参数，也可以使用 SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar，java -Dspring.application.json='{"name":"test"}' -jar myapp.jar 或 java -jar myapp.jar --spring.application.json='{"name":"test"}' 的方式，通过 json 来设置属性值。

29.1.3 Custom JSON Serializers and Deserializers
	使用 @JsonComponent 注解一个类，在内部定义 JsonSerializer<T> 和 JsonDeserializer<T> 的子类，实现自定义的 JSON 序列化和反序列化。

29.1.11 Error Handling
	通过一个 ErrorController 的实现类，可以定义一个监听 /error 的接口，从而实现定制化的错误返回（如果直接监听接口而不实现这个类的话，SpringBoot 启动时会报错，因为在 BasicErrorController 中已经对这个路径进行了监听）。也可以定义一个继承自 BasicErrorController 的类，再定义一个 @RequestMapping 的方法，同时制定一个不同于 text/html 的 produces 属性（BasicErrorController 中的 error 方法会返回  text/html 格式的数据，不能和它重复）。
	RequestMapping 注解中，有 consumes 和 produces 两个属性。consumes 指定服务器处理请求时，客户端应该传的数据的类型（headers 中的 Content-Type）。produces 指定服务器处理请求后，客户端可以接受的数据类型（headers 中的 Accept）。

31.1.2 Connection to a Production Database
    使用 spring.datasource.* 去配置数据库的 datastore 信息，而不需要指定特定的 datastore 实现，SpringBoot 按照以下顺序去自动加载实现类。
	1、HikariCP 
	2、Tomcat pooling DataSource
	3、Commons DBCP2
	使用 spring.datasource.hikari.*、spring.datasource.tomcat.*、spring.datasource.dbcp2.* 去设置特定的 datastore 实现的属性

33. Caching
    在启动类上使用 @EnableCaching 注解可以开启 SpringBoot 缓存模式，在 Spring Bean 的方法或类上使用 @Cacheable 注解可以使该方法或该类的所有方法成为缓存方法。Spring 会根据方法参数或通过自定义的方式生成缓存的 key，并把方法返回值作为 value 缓存起来。
	通过引入 spring-boot-starter-cache 依赖可以添加一个基本的 cache 依赖到项目中。
	如果项目中包含 Redis，SpringBoot 会自动配置一个 RedisCacheManager，使缓存数据可以存到 Redis 上。
	使用 spring.cache.cache-names=cache1,cache2 可以指定仅仅创建和使用哪些缓存，而不是在需要时任意创建。
	使用 spring.cache.type=none 禁用缓存。

34. Messaging
	Spring Boot 可以方便地计入多种消息中间件。如：使用 JMS 抽象，利用 JmsTemplate 模版来使用统一的消息发送，利用 @JmsListener 注解来接受消息。支持 ActiveMQ 和 Artemis。使用 Advanced Message Queuing Protocol (AMQP) 接入 RabbitMQ。使用 spring-kafka 方便地与 kafka 服务器进行通信。利用 KafkaTemplate 和 @KafkaListener 可以快速地发送和接受 kafka 消息。

37. Validation
    当 JSR-303 的实现（如：Hibernate validator）在 classpath 的时候，基于 Bean Validation 1.1 的方法校验的功能自动可用。javax.validation 包下的注解可以约束参数和返回值。需要使用 @Validated 对类进行注解。

38. Sending Email
    引入 spring-boot-starter-mail 包并配置 spring.mail.host 属性，可以方便地使用 JavaMailSender 发送邮件。

39. Distributed Transactions with JTA
    SpringBoot 可以集成多种事务管理器，包括 Atomikos 和 Bitronix 等。

40. Hazelcast
    Hazelcast 是一个基于内存的数据网格开源项目，当集群中的一个节点修改某一部分内存数据时，其他节点的内存中的数据也会被修改。可以用于实现同一个服务多个实例需要共享同一份数据的功能（例如 session 管理、数据缓存等）。

41. Quartz Scheduler
    使用 Quartz Scheduler 可以方便地管理定时任务。默认使用内存型的定时任务，也可以配置从数据库读取定时任务配置信息，以达到动态控制定时任务和集群共享的目的。

42. Task Execution and Scheduling
    可以自定义异步线程执行器

43. Spring Integration
    Spring Integration 是一个功能强大的EIP(Enterprise Integration Patterns，企业集成模式)，是一种便捷的可以在系统之间做消息传递的事件驱动消息框架。Message 用于封装消息，包括 Hearder 和 Payload 两部分；MessageChannel 可以使用不同的方式来发送接收消息；Message Endpoint 可以对消息进行一些如转换、过滤、路由等操作；Channel Interceptor 可以在消息各个阶段进行拦截。

44. Spring Session
    Spring Session 模块可以方便地管理 Session，并且可以配置保存 session 的位置，包括 JDBC、Redis、Hazelcast、MongoDB 等。

46.3 Testing Spring Boot Applications
    使用 @Transactional 注解测试方法，可以在测试方法结束之前进行事务回滚，但使用 RANDOM_PORT，DEFINED_PORT 模式启动的模式不能进行回滚，因为 SpringBoot 创建了真实的 web server。
    使用 MockMvc 或 WebTestClient 可以方便地对 controller 进行测试。MockMvc 可以使用 @Autowired 注入，WebTestClient 对测试类进行注解，可以仅仅扫描 controller 层的 beans。
    使用 MockRestServiceServer 可以模拟一个 web 服务端，以便对 REST Clients 进行测试。
——————————————————————————————————————————————————————————————————————————
https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#production-ready