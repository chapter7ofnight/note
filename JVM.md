#### 一、JVM 内存结构

##### 1、程序计数器

​		线程私有，用来表示当前线程当前执行的字节码所在行号，如果当前执行的是本地方法，这个变量为 undefined。

##### 2、虚拟机栈

​		线程私有，用来表示当前线程所执行的方法栈。这块区域可以是固定大小，也可以是动态扩展的。如果栈深度达到了允许的深度，会抛出 StackOverflowError 错误。如果允许动态扩展，但没有可使用的空间，会抛出 OutOfMemoryError 错误。

每个方法调用会创建一个栈帧，栈帧的大小在编译期确定，所以其实际空间只取决于 JVM 的实现。

a）局部变量表：包括 8 种基本类型、reference 和 returnAddress 组成的数组，编译期确定。

b）操作数栈：在编译期确定最大深度。

c）动态链接：对当前方法在运行时常量池的引用，一个方法通过符号引用其他方法，动态链接把发好引用翻译成方法引用。

d）常规方法调用：可能有对应类型的返回值，回复调用方的状态。

e）异常方法调用：方法内部发生未捕获的异常。

##### 3、堆

​		线程共享，用来保存所有实例和数组的区域。如果需要分配空间但没有更多空间可使用时，会抛出 OutOfMemoryError 错误。

一般来说，堆是 JVM 中分配内存最多的部分。

a）新生区：大部分对象（没有大到 Eden 区放不下的对象，或大于 PretenureSizeThreshold 的对象）在 Eden 区生成。Eden 区满时，进行一次 Minor GC，将 Eden 区和 Survive From 区仍存活的对象年龄大于 MaxTenuringThreshold（15）的复制到老年代，Survive To 区空间不足时也会复制到老年代，其他的复制到 Survive To 区，对象年龄 +1，然后清空 Eden 和 Survive From 区。Survive From 和 To 区互换。

b）老年代：经历过多次 Minor GC 后仍存在的对象，或者 Minor GC 时，Survive To 区无法容纳的对象。当老年代没有足够的空间来保存需要进入老年代的对象时，会发生一次 Full GC（包括 Major GC 和 Minor GC），Major GC 回收老年代的空间。

##### 4、方法区

​		线程共享，用来保存类信息、运行时常量池、静态变量、构造器、即时编译器编译后的代码等。可以抛出 OutOfMemoryError 错误。JDK 1.8 使用本地内存中的元数据区来代替方法区的实现，而运行时常量池存放位置不变。

##### 5、运行时常量池

​		编译期生成的各种字面量和符号引用。

##### 6、本地方法栈

​		线程私有，用来表示当前线程本地方法的执行栈。对于特定的 JVM 实现，可能没有这部分区域。可以抛出 StackOverflowError 和 OutOfMemoryError 错误。



#### 二、垃圾回收器

##### 1、CMS（Concurrent Mark Sweep）

​		以最短回收停顿时间为目标**老年代**垃圾回收器。初始标记：需要停顿，标记 GC Roots 直接关联的对象；并发标记：并发不停顿，标记所有对象；重新标记：需要停顿，修正并发标记结果；并发清除：清除被标记为不可用的对象。缺点：占用 CPU 资源；无法处理浮动垃圾，需要预留空间给清除阶段时产生的对象；清除产生的内存碎片，需要设置多少次 GC 进行一次压缩（默认每次都压缩）。

##### 2、G1

​		垃圾回收器最前沿的成果，JDK9 默认回收器。初始标记：需要停顿，标记 GC Roots 直接关联的对象；并发标记：并发不停顿，标记所有对象；最终标记：需要停顿，但可以并行执行，合并 Remembered Set Logs 数据到 Remembered Set 中；筛选回收：对 Region 回收价值排序，并回收部分价值最高的 Region。

​		可以利用多核 CPU 并行执行，可以管理**整个堆**，不会产生空间碎片，可预测的停顿。内存被划分为若干个 Region 的集合，通过一个优先队列保存各 Region 回收的价值；通过 Remembered Set 来记录当前 Region 内对象被其他 Region 内对象引用的情况，以此避免扫描整个堆。

##### 3、Parallel

​		JDK1.8 默认的**新生代**回收器。使用并行多线程，复制算法，目标是达到可控制的吞吐量的回收器。

##### 4、Parallel Old

​		JDK1.8 默认的**老年代**回收器。使用多线程，标记-整理算法的回收器，配合 Parallel 使用。

##### 5、其他

​		Serial：新生代，单线程，需要停顿，复制算法。

​		ParNew：新生代，多线程，需要停顿，复制算法。

​		Serial Old：老年代，单线程，需要停顿，标记-整理算法。



#### 三、Java 内存模型（JMM）

##### 1、主内存和工作内存

​		所有可共享的数据都应该保存在主内存里面，每个线程有自己工作内存，数据为主内存的拷贝。

##### 2、内存交互

​		lock、unlock：对主内存变量锁定和解锁。可重入锁。lock 时清空工作内存。unlock 时，必须先 store、write。

​		read、load：必须顺序执行，读主内存到工作内存，然后赋值到变量。是变量 use、store 的条件。

​		use：使用工作内存变量。

​		assign：对工作内存变量赋值。assign 之后必须 store、write；没有 assign 则不能 store、write。

​		store、write：必须顺序执行，写工作内存到主内存，然后赋值到变量。

volatile 关键字保证 load 和 use 必须连续进行，assign 和 store 必须连续进行，从而保证了数据的可见性。防止指令重排序优化，内存屏障。

​		LoadLoad：后续读之前，前面的读完毕；放在读操作后面

​		StoreStore：后续写之前，前面的写完毕；放在写操作前面

​		LoadStore：后续写之前，前面的读完毕；放在读操作后面

​		StoreLoad：后续读之前，前面的写完毕；放在写操作后面

##### 3、原子性、可见性和有序性

​		原子性：read、load、use、assign、store、write；synchronized 通过 monitorenter 和 monitorexit 锁来保证原子性。

​		可见性：volatile；synchronized 通过 unlock 的语义保证原子性；final 不可变。

​		有序性：volatile；synchronized 通过 lock 的语义保证有序性。

##### 4、先行发生原则

​		程序次序：代码书写顺序（控制流顺序）

​		管程锁定：unlock 先行发生于后面对同一个锁的 lock

​		volatile：写先行发生于后面对同一变量的读

​		线程启动：start() 方法先于其他动作

​		线程终止：所有动作先于终止检测

​		线程中断：interrupt() 方法先于检测到中断事件

​		对象终结：初始化完成先于 finalize() 方法

​		传递性



#### 四、类

##### 1、class 文件结构

​		整个文件由**无符号数**和**表**组成。

​		魔数和版本号。常量池（字符串， final 等常量；类和接口的全限定名，字段和方法的名称和描述符等符号引用）。访问标志。类索引、父类索引和接口索引集合。字段表集合。方法表集合。属性表集合。

##### 2、类加载

a）类加载过程：加载，连接（验证，准备，解析），初始化，使用，卸载。

b）初始化时机：new，访问静态字段或静态方法；反射调用；子类初始化时先初始化父类；主类；

##### 3、类加载器

a）包括：BootStrap ClassLoader、Extension ClassLoader、Application ClassLoader 和 User ClassLoader。

b）通过双亲委派机制，使所有的类加载优先通过父类加载器进行加载，以保证加载的类的唯一性。

c）继承 ClassLoader，重写 loadClass 方法可以打破双亲委派机制。动态热部署，将类分成不同的模块，使用不同的类加载器去加载，替换模块时，连同类加载器一起替换，以实现代码热替换。线程上下文类加载器，允许设置这样的加载器到线程中，以便父类加载器通过子类加载器去加载类。

##### 4、对象的内存结构

a）对象头：运行时数据，包括哈希码、GC 年龄、锁状态、偏向锁。占 32 位或64 位。类型指针，包括数组长度和 class 信息指针。

b）实例数据

c）对齐填充，使对象大小为 8 字节的整数倍。



#### 五、线程与锁

##### 1、线程的状态

​		新建。运行，正在运行或等待 CPU 分配执行时间。无限期等待，需要被显式唤醒（Object.wai()、Thread.join()、LockSupport.park()）。限期等待，过一段时间唤醒（Thread.sleep()、LockSupport.parkNanos()、LockSupport.parkUntil()）。阻塞，等待一个锁。结束。

##### 2、实现线程安全

a）互斥同步：synchronized 关键字和 ReentrantLock 实现。悲观锁。

b）非阻塞同步：CAS。乐观锁。

c）不同步：纯代码。ThreadLocal。

##### 3、锁优化（synchronized）

a）自旋和适应性自旋

b）锁消除

c）锁粗化

d）偏向锁：对象偏袒于第一个获取到它的线程，这个线程对这个对象的操作不需要任何同步。当有其他线程尝试获取这个锁时，退化为轻量级锁。

e）轻量级锁：在线程栈帧中创建一个锁记录，储存拷贝的对象头。用 CAS 改变原对象头的指针，获得轻量级锁。如果发现有其他线程占用该锁，则膨胀为重量级锁，线程进入阻塞状态。



#### 六、常用命令和参数

##### 1、常用命令

a）jps：获取正在运行的虚拟机进程

b）jinfo：查看虚拟机运行的参数

c）jmap：生成 JVM 内存快照，查看内存信息

d）jstack：查看线程快照

e）JConsole：可视化 JVM 监控平台

##### 2、JVM 常用参数

a）-Xmx、-Xms 设置堆的大小

b）-XX:NewRatio、-XX:SurvivorRatio 设置堆内存区域的大小比例

c）-XX:Use* 使用某一种垃圾回收器。

d）-XX:HeapDumpOnOutOfMemoryError OOM 时自动 dump 内存快照

e）-XX:PrintGC 打印 GC 信息