https://netty.io/wiki/user-guide-for-4.x.html

https://livebook.manning.com/book/netty-in-action

Netty 是一个异步、事件驱动的网络应用框架，也是快速构建的可维护的、高性能和高可扩展的服务器和客户端协议的工具。

核心概念：
1、Bootstrap or ServerBootstrap
	用于引导一个服务端或客户端的类，继承自同一个父类 AbstractBootstrap，可以通过方法链的形式进行配置。
2、EventLoop
3、EventLoopGroup
4、ChannelPipeline
5、Channel
6、Future or ChannelFuture
7、ChannelInitializer
8、ChannelHandler

首要构建块：
1、Channel
	数据传输的媒介
2、Callbacks
	回调，某一事件完成后执行的逻辑
3、Future
4、Events and handlers


SimpleChannelInboundHandler 会自动释放 ByteBuf 的资源

Channel ChannelPipeline ChannelHandler
transports包括：NIO、Epoll、OIO、Local、Embedded
异步框架可以支持OIO的原因：Netty 会设置一个IO等待的最大时间，超时则抛出异常。这个异常被捕获之后，Netty会继续线程的循环。

ByteBuf、ByteBufHolder：
可以扩展成用户定义的缓存类型
零拷贝
容量可按需扩展
读写切换时不需要反转（读写使用的是独立的索引）
支持方法链、参考计数和池

ButeBuf 分配区域
堆：方便
直接内存：分配和释放资源的开销更大，如果需要对byte[]进行操作，需要先复制内容带堆上
组合类型：组合多个以上两种类型

ByteBuf API
1、下标随机访问
2、已读数据可以通过 discardReadBytes 方法来回收资源。这个方法调用之后，会把数据整体前移到最前端，所以有一定的复制数据的开销
3、markReaderIndex(), markWriterIndex(), resetReaderIndex(), and resetWriterIndex()，readerIndex(int) or writerIndex(int) 方法可以设置索引，clear() 方法把整个区域编程写区域
4、forEachByte 方法可以用来查找指定的字符
5、duplicate()、slice()、slice(int, int)、Unpooled.unmodifiableBuffer(…)、order(ByteOrder)、readSlice(int) 得到当前 ButeBuf 的一个新的视图。但 copy() or copy(int,int)方法会复制一份新的数据
6、get() and set() 改变数据但不改变索引，read() and write() 改变数据之后自动改变索引

ByteBufHolder 是一个可以保存 ByteBuf 的接口，content() 返回 ByteBuf，copy() 深拷贝，duplicate() 浅拷贝

ByteBufAllocator 用于为 ByteBuf 分配内存。heapBuffer() 分配堆内存，directBuffer() 分配直接内存，buffer()的内存取决于实现，compositeBuffer() 组合类型的 ByteBuf。
通过 channel.alloc() 或  ctx.alloc() 方法可以获取到 ByteBufAllocator 的对象。PooledByteBufAllocator分配池化内存，UnpooledByteBufAllocator分配非池化内存。
Unpooled 类是上述接口的一个替代，可以使用static方法进行内存分配
ByteBufUtil 一个操作 ByteBuf 的工具类，hexdump() 得到十六进制，equals(ByteBuf, ByteBuf) 比较两个 ByteBuf 是否相同
ReferenceCounted 引入计数的接口，表示当前对象（主要是ByteBuf）被多少地方引用了。一旦 refCnt() 为0，表示这个对象不可再被使用。

Channel：ChannelRegistered -> ChannelActive -> ChannelInactive -> ChannelUnregistered
ChannelHandler：handlerAdded，handlerRemoved，exceptionCaught
ChannelInboundHandlerAdapter -> ChannelInboundHandler
						-> ChannelHandlerAdapter	-> ChannelHandler
ChannelOutboundHandlerAdapter -> ChannelOutboundHandler
SimpleChannelInboundHandler：自动释放内存

ChannelInboundHandler.channelRead()，ChannelOutboundHandler.write() 方法调用之后，如果不需要再使用 ByteBuf，应该手动释放这个资源。
ResourceLeakDetector 是一个用于检测 netty 内存泄露的辅助类，包括DISABLED、SIMPLE（默认）、ADVANCED、PARANOID四个级别。java -Dio.netty.leakDetectionLevel=ADVANCED；ResourceLeakDetector.setLevel()

Channel 分配一个 ChannelPipeline，在 Channel 的整个生命周期里，这个 ChannelPipeline 不可改变。
注册在 ChannelPipeline 中的 ChannelHandler 既有 ChannelInboundHandler 也有 ChannelOutboundHandler，在事件到达的时候，程序会去遍历，只执行对应的 ChannelHandler 的代码。
ChannelHandler 可以添加、删除、替代 ChannelPipeline 里的任意 ChannelHandler，包括它自己

ChannelHandler 被添加到 ChannelPipeline 的时候会创建一个 ChannelHandlerContext 对象，用于管理 ChannelHandler 和 ChannelPipeline（和其中的ChannelHandler）的联系
ChannelHandlerContext 中的一些方法 Channel 和 ChannelPipeline 中也有，但前者只作用当前 ChannelHandler 和下一个 ChannelHandler。
ChannelHandler 可以被添加到多个 ChannelPipeline，只要使用 @Sharable，并保证所有方法都是线程安全的。常用于统计。
异常处理：覆盖 ChannelInboundHandler 的 exceptionCaught 方法；在 ChannelOutboundHandler 方法返回的 ChannelFuture 中添加 ChannelFutureListener，或者在方法中的 ChannelPromise 对象添加 ChannelFutureListener

一个 EventLoop 拥有一个 Thread，可以绑定多个 Channel。
《Netty In Action》中说如果某个线程调用 Channel 的方法时，会判断是否为 Channel 绑定线程。是则直接执行，否则task加入EventLoop任务队列。但是源码显示，task都是加入队列，区别是非绑定线程时会先判断是否需要开启新线程
不管以上两种情况，netty 保证执行
NioEventLoopGroup 如果不指定线程数，默认设置为 16，同时也是 EventLoop 的数量。第一个任务和非Channel线程的任务提交之后，会调用SingleThreadEventExecutor的startThread方法，只有在这个 EventLoop 还没有绑定线程的时候会启动新的线程。
问题：在源码中发现，创建一个 EventLoopGroup 时默认有 16 个 EventLoop，但是通常只有一个被绑定到 Channel 对象上。而在外部是可以获取到所有这 16 个对象的，也就是说，外部线程可以把任务提交到任意一个 EventLoop 的队列中，那么执行的 Thread 就不是同一个了，如何保证线程安全呢？
调用 EventLoopGroup.shutdownGracefully() 来释放资源，然后结束程序

ByteToMessageDecoder：转 ByteBuf 为 Object 的抽象方法，所有 Decoder 的父类
ReplayingDecoder：不需要判断读取 Byte 的长度，如果不够长，会抛出异常，异常被捕获后，再有 Byte 进来时继续调用这个方法。简单，但是消耗更大。
MessageToMessageDecoder：一种信息转为另一种信息
MessageToByteEncoder：泛型对象转为 ByteBuf
MessageToMessageEncoder：泛型转 Object
ByteToMessageCodec：泛型和 ByteBuf 互转
MessageToMessageCodec：泛型和 Object 互转
CombinedChannelDuplexHandler：组合 in（decoder） 和 out（encoder）































